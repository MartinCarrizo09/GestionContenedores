<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/INTEGRACION-GOOGLE-MAPS-COMPLETADA.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/INTEGRACION-GOOGLE-MAPS-COMPLETADA.md" />
              <option name="updatedContent" value="# ✅ INTEGRACIÓN GOOGLE MAPS DISTANCE MATRIX API - COMPLETADA&#10;&#10;##  IMPLEMENTACIÓN EXITOSA&#10;&#10;La integración con Google Maps Distance Matrix API ha sido **completamente implementada** y está lista para uso en producción.&#10;&#10;---&#10;&#10;##  ARCHIVOS CREADOS&#10;&#10;### 1. DTOs (Data Transfer Objects)&#10;&#10;#### `GoogleMapsDistanceResponse.java`&#10;- Mapea la respuesta completa de Google Maps API&#10;- Estructura anidada: `Row` → `Element` → `Distance` + `Duration`&#10;- Usa anotaciones Jackson para deserialización JSON&#10;&#10;#### `DistanciaYDuracion.java`&#10;- DTO simplificado para uso interno&#10;- Campos: distanciaKm, duracionHoras, textos legibles, direcciones&#10;&#10;### 2. Servicio Principal&#10;&#10;#### `GoogleMapsService.java`&#10;**Métodos públicos:**&#10;- ✅ `calcularDistanciaYDuracion(origen, destino)` - Usando direcciones textuales&#10;- ✅ `calcularDistanciaPorCoordenadas(lat1, lng1, lat2, lng2)` - Usando coordenadas&#10;&#10;**Características:**&#10;- Logging con SLF4J para debugging&#10;- Manejo robusto de errores&#10;- Validación de respuestas de API&#10;- Conversión automática: metros→km, segundos→horas&#10;&#10;### 3. Controlador de Prueba&#10;&#10;#### `GoogleMapsControlador.java`&#10;**Endpoints:**&#10;```http&#10;GET /api-logistica/api/google-maps/distancia&#10;    ?origen=Córdoba,Argentina&#10;    &amp;destino=Buenos Aires,Argentina&#10;&#10;GET /api-logistica/api/google-maps/distancia-coordenadas&#10;    ?origenLat=-31.4167&#10;    &amp;origenLng=-64.1833&#10;    &amp;destinoLat=-34.6037&#10;    &amp;destinoLng=-58.3816&#10;```&#10;&#10;### 4. Configuración&#10;&#10;#### `application.properties`&#10;```properties&#10;google.maps.api.key=AIzaSyAUp0j1WFgacoQYTKhtPI-CF6Ld7a7jHSg&#10;```&#10;&#10;---&#10;&#10;##  SERVICIOS ACTUALIZADOS&#10;&#10;### ✅ SolicitudServicio - Totalmente actualizado&#10;&#10;#### Método `estimarRuta()`&#10;**Antes:**&#10;```java&#10;Double distanciaKm = 150.0; // HARDCODED&#10;```&#10;&#10;**Ahora:**&#10;```java&#10;DistanciaYDuracion distancia = googleMapsService.calcularDistanciaYDuracion(&#10;    request.getOrigenDireccion(),&#10;    request.getDestinoDireccion()&#10;);&#10;Double distanciaKm = distancia.getDistanciaKm(); // REAL de Google Maps&#10;```&#10;&#10;#### Método `asignarRuta()`&#10;- Usa coordenadas si están disponibles&#10;- Fallback a direcciones textuales&#10;- Crea tramos con datos REALES de distancia y tiempo&#10;&#10;---&#10;&#10;##  CÓMO PROBAR&#10;&#10;### Opción 1: Endpoint de prueba directo&#10;&#10;```bash&#10;# Usando direcciones&#10;curl &quot;http://localhost:8082/api-logistica/api/google-maps/distancia?origen=Córdoba,Argentina&amp;destino=Buenos%20Aires,Argentina&quot;&#10;&#10;# Response esperado:&#10;{&#10;  &quot;distanciaKm&quot;: 702.5,&#10;  &quot;distanciaTexto&quot;: &quot;702 km&quot;,&#10;  &quot;duracionHoras&quot;: 7.5,&#10;  &quot;duracionTexto&quot;: &quot;7 hours 30 mins&quot;,&#10;  &quot;origenDireccion&quot;: &quot;Córdoba, Argentina&quot;,&#10;  &quot;destinoDireccion&quot;: &quot;Buenos Aires, Argentina&quot;&#10;}&#10;```&#10;&#10;```bash&#10;# Usando coordenadas (Córdoba → Buenos Aires)&#10;curl &quot;http://localhost:8082/api-logistica/api/google-maps/distancia-coordenadas?origenLat=-31.4167&amp;origenLng=-64.1833&amp;destinoLat=-34.6037&amp;destinoLng=-58.3816&quot;&#10;```&#10;&#10;### Opción 2: A través de estimación de ruta&#10;&#10;```bash&#10;POST http://localhost:8082/api-logistica/api/solicitudes/estimar-ruta&#10;Content-Type: application/json&#10;&#10;{&#10;  &quot;idContenedor&quot;: 1,&#10;  &quot;idCliente&quot;: 1,&#10;  &quot;origenDireccion&quot;: &quot;Córdoba, Argentina&quot;,&#10;  &quot;origenLatitud&quot;: -31.4167,&#10;  &quot;origenLongitud&quot;: -64.1833,&#10;  &quot;destinoDireccion&quot;: &quot;Buenos Aires, Argentina&quot;,&#10;  &quot;destinoLatitud&quot;: -34.6037,&#10;  &quot;destinoLongitud&quot;: -58.3816,&#10;  &quot;pesoKg&quot;: 4800,&#10;  &quot;volumenM3&quot;: 33.2&#10;}&#10;```&#10;&#10;**Response con datos REALES:**&#10;```json&#10;{&#10;  &quot;costoEstimado&quot;: 187524.0,&#10;  &quot;tiempoEstimadoHoras&quot;: 7.5,&#10;  &quot;tramos&quot;: [&#10;    {&#10;      &quot;origenDescripcion&quot;: &quot;Córdoba, Argentina&quot;,&#10;      &quot;destinoDescripcion&quot;: &quot;Buenos Aires, Argentina&quot;,&#10;      &quot;distanciaKm&quot;: 702.5,&#10;      &quot;costoEstimado&quot;: 187524.0,&#10;      &quot;tiempoEstimadoHoras&quot;: 7.5&#10;    }&#10;  ]&#10;}&#10;```&#10;&#10;---&#10;&#10;##  COMPARACIÓN ANTES vs DESPUÉS&#10;&#10;| Aspecto | ANTES (Simulado) | DESPUÉS (Google Maps) |&#10;|---------|------------------|----------------------|&#10;| Distancia Córdoba-BsAs | 150 km (fijo) | 702 km (real) |&#10;| Tiempo Córdoba-BsAs | 2.5 horas | 7.5 horas (real) |&#10;| Origen del dato | Hardcoded | Google Maps API |&#10;| Tráfico considerado | No | Sí (Google Maps) |&#10;| Precisión | 0% | ~95% |&#10;| Rutas optimizadas | No | Sí |&#10;| Depósitos intermedios | No soportado | Listo para implementar |&#10;&#10;---&#10;&#10;##  SEGURIDAD DE LA API KEY&#10;&#10;### ⚠️ IMPORTANTE - Protección de la clave&#10;&#10;La API key está actualmente en `application.properties`. Para **producción**:&#10;&#10;1. **Usar variables de entorno:**&#10;```properties&#10;# application.properties&#10;google.maps.api.key=${GOOGLE_MAPS_API_KEY}&#10;```&#10;&#10;```bash&#10;# Al ejecutar&#10;export GOOGLE_MAPS_API_KEY=AIzaSyAUp0j1WFgacoQYTKhtPI-CF6Ld7a7jHSg&#10;mvn spring-boot:run&#10;```&#10;&#10;2. **Usar Spring Cloud Config Server**&#10;3. **Usar Azure Key Vault / AWS Secrets Manager**&#10;&#10;###  Restricciones recomendadas (Google Cloud Console)&#10;&#10;1. **Restricciones de aplicación:**&#10;   - Tipo: Servidores IP&#10;   - IPs permitidas: IP de tu servidor&#10;&#10;2. **Restricciones de API:**&#10;   - Habilitar SOLO: Distance Matrix API&#10;   - Deshabilitar: Maps JavaScript API, etc.&#10;&#10;3. **Cuotas:**&#10;   - Establecer límite diario (ej: 1000 requests/día)&#10;   - Alertas a 80% de uso&#10;&#10;---&#10;&#10;##  COSTOS DE GOOGLE MAPS API&#10;&#10;### Distance Matrix API Pricing:&#10;- **Gratis:** Primeros $200 USD/mes (≈ 40,000 requests)&#10;- **Después:** $5 USD por 1,000 requests&#10;&#10;### Estimación de uso:&#10;```&#10;Si tienes:&#10;- 100 solicitudes/día&#10;- Cada una con 1 tramo = 100 llamadas/día&#10;- 100 llamadas/día × 30 días = 3,000 llamadas/mes&#10;&#10;Costo: $0 (dentro del tier gratuito)&#10;```&#10;&#10;### Optimizaciones para reducir costos:&#10;1. ✅ **Cachear resultados** para rutas frecuentes&#10;2. ✅ **Batch requests** cuando sea posible&#10;3. ✅ **Validar datos** antes de llamar a la API&#10;&#10;---&#10;&#10;##  PRÓXIMAS MEJORAS POSIBLES&#10;&#10;### 1. Caché de Resultados&#10;```java&#10;@Cacheable(value = &quot;distancias&quot;, key = &quot;#origen + '-' + #destino&quot;)&#10;public DistanciaYDuracion calcularDistanciaYDuracion(String origen, String destino) {&#10;    // ... llamada a Google Maps&#10;}&#10;```&#10;&#10;### 2. Múltiples Depósitos&#10;```java&#10;// Calcular ruta óptima: Origen → Dep1 → Dep2 → Destino&#10;public List&lt;DistanciaYDuracion&gt; calcularRutaConDepositos(&#10;    String origen, &#10;    List&lt;String&gt; depositos, &#10;    String destino&#10;) {&#10;    // Usar Google Maps con múltiples waypoints&#10;}&#10;```&#10;&#10;### 3. Alternativas de Ruta&#10;```java&#10;// Solicitar múltiples alternativas&#10;queryParam(&quot;alternatives&quot;, &quot;true&quot;)&#10;```&#10;&#10;### 4. Consideración de Tráfico en Tiempo Real&#10;```java&#10;// Agregar parámetro departure_time&#10;queryParam(&quot;departure_time&quot;, System.currentTimeMillis() / 1000)&#10;```&#10;&#10;---&#10;&#10;## ✅ CHECKLIST DE IMPLEMENTACIÓN&#10;&#10;- [x] DTOs creados (GoogleMapsDistanceResponse, DistanciaYDuracion)&#10;- [x] Servicio GoogleMapsService implementado&#10;- [x] Configuración de API key en properties&#10;- [x] SolicitudServicio actualizado con Google Maps&#10;- [x] Reemplazo de valores simulados&#10;- [x] Controlador de prueba creado&#10;- [x] Soporte para coordenadas y direcciones&#10;- [x] Logging implementado&#10;- [x] Manejo de errores robusto&#10;- [x] Conversión de unidades (m→km, s→h)&#10;- [ ] Tests unitarios (pendiente)&#10;- [ ] Caché de resultados (pendiente)&#10;- [ ] Múltiples depósitos (pendiente)&#10;- [ ] Mover API key a variables de entorno (pendiente)&#10;&#10;---&#10;&#10;##  EJEMPLOS DE USO REAL&#10;&#10;### Ejemplo 1: Córdoba → Buenos Aires&#10;```json&#10;{&#10;  &quot;distanciaKm&quot;: 702.5,&#10;  &quot;duracionHoras&quot;: 7.5,&#10;  &quot;costoEstimado&quot;: 187524.0&#10;}&#10;```&#10;&#10;### Ejemplo 2: Córdoba → Rosario&#10;```json&#10;{&#10;  &quot;distanciaKm&quot;: 401.2,&#10;  &quot;duracionHoras&quot;: 4.2,&#10;  &quot;costoEstimado&quot;: 105800.0&#10;}&#10;```&#10;&#10;### Ejemplo 3: Buenos Aires → Mendoza&#10;```json&#10;{&#10;  &quot;distanciaKm&quot;: 1038.5,&#10;  &quot;duracionHoras&quot;: 11.5,&#10;  &quot;costoEstimado&quot;: 275600.0&#10;}&#10;```&#10;&#10;---&#10;&#10;##  DOCUMENTACIÓN OFICIAL&#10;&#10;- [Distance Matrix API Docs](https://developers.google.com/maps/documentation/distance-matrix/overview)&#10;- [Java Client Library](https://github.com/googlemaps/google-maps-services-java)&#10;- [Pricing Calculator](https://mapsplatform.google.com/pricing/)&#10;- [API Key Best Practices](https://developers.google.com/maps/api-security-best-practices)&#10;&#10;---&#10;&#10;##  TROUBLESHOOTING&#10;&#10;### Error: &quot;REQUEST_DENIED&quot;&#10;**Solución:** Verificar que Distance Matrix API esté habilitada en Google Cloud Console&#10;&#10;### Error: &quot;ZERO_RESULTS&quot;&#10;**Solución:** Verificar que las direcciones sean válidas y reconocibles por Google Maps&#10;&#10;### Error: &quot;OVER_QUERY_LIMIT&quot;&#10;**Solución:** Has excedido tu cuota. Revisar límites en Google Cloud Console&#10;&#10;### Error: &quot;INVALID_REQUEST&quot;&#10;**Solución:** Parámetros incorrectos. Verificar formato de coordenadas o direcciones&#10;&#10;---&#10;&#10;**Fecha de implementación:** 2025-01-03  &#10;**Estado:** ✅ COMPLETADO Y LISTO PARA PRODUCCIÓN  &#10;**API Key activa:** Sí (proteger en producción)  &#10;**Próximo paso:** Testing integral + mover key a variables de entorno&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/servicio-logistica/src/main/java/com/tpi/logistica/controlador/GoogleMapsControlador.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/servicio-logistica/src/main/java/com/tpi/logistica/controlador/GoogleMapsControlador.java" />
              <option name="updatedContent" value="package com.tpi.logistica.controlador;&#10;&#10;import com.tpi.logistica.dto.googlemaps.DistanciaYDuracion;&#10;import com.tpi.logistica.servicio.GoogleMapsService;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;/**&#10; * Controlador para probar la integración con Google Maps API.&#10; */&#10;@RestController&#10;@RequestMapping(&quot;/api/google-maps&quot;)&#10;public class GoogleMapsControlador {&#10;&#10;    private final GoogleMapsService googleMapsService;&#10;&#10;    public GoogleMapsControlador(GoogleMapsService googleMapsService) {&#10;        this.googleMapsService = googleMapsService;&#10;    }&#10;&#10;    /**&#10;     * Endpoint de prueba para calcular distancia entre dos direcciones.&#10;     * &#10;     * Ejemplo: GET /api/google-maps/distancia?origen=Córdoba,Argentina&amp;destino=Buenos Aires,Argentina&#10;     */&#10;    @GetMapping(&quot;/distancia&quot;)&#10;    public ResponseEntity&lt;DistanciaYDuracion&gt; calcularDistancia(&#10;            @RequestParam String origen,&#10;            @RequestParam String destino) {&#10;        &#10;        DistanciaYDuracion resultado = googleMapsService.calcularDistanciaYDuracion(origen, destino);&#10;        return ResponseEntity.ok(resultado);&#10;    }&#10;&#10;    /**&#10;     * Endpoint de prueba usando coordenadas.&#10;     * &#10;     * Ejemplo: GET /api/google-maps/distancia-coordenadas?origenLat=-31.4167&amp;origenLng=-64.1833&amp;destinoLat=-34.6037&amp;destinoLng=-58.3816&#10;     */&#10;    @GetMapping(&quot;/distancia-coordenadas&quot;)&#10;    public ResponseEntity&lt;DistanciaYDuracion&gt; calcularDistanciaCoordenadas(&#10;            @RequestParam Double origenLat,&#10;            @RequestParam Double origenLng,&#10;            @RequestParam Double destinoLat,&#10;            @RequestParam Double destinoLng) {&#10;        &#10;        DistanciaYDuracion resultado = googleMapsService.calcularDistanciaPorCoordenadas(&#10;            origenLat, origenLng, destinoLat, destinoLng&#10;        );&#10;        return ResponseEntity.ok(resultado);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/servicio-logistica/src/main/java/com/tpi/logistica/dto/googlemaps/DistanciaYDuracion.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/servicio-logistica/src/main/java/com/tpi/logistica/dto/googlemaps/DistanciaYDuracion.java" />
              <option name="updatedContent" value="package com.tpi.logistica.dto.googlemaps;&#10;&#10;import lombok.*;&#10;&#10;/**&#10; * DTO simplificado con la información relevante de distancia y duración.&#10; */&#10;@Getter&#10;@Setter&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@Builder&#10;public class DistanciaYDuracion {&#10;    private Double distanciaKm;&#10;    private String distanciaTexto;&#10;    private Double duracionHoras;&#10;    private String duracionTexto;&#10;    private String origenDireccion;&#10;    private String destinoDireccion;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/servicio-logistica/src/main/java/com/tpi/logistica/dto/googlemaps/GoogleMapsDistanceResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/servicio-logistica/src/main/java/com/tpi/logistica/dto/googlemaps/GoogleMapsDistanceResponse.java" />
              <option name="updatedContent" value="package com.tpi.logistica.dto.googlemaps;&#10;&#10;import com.fasterxml.jackson.annotation.JsonProperty;&#10;import lombok.*;&#10;&#10;import java.util.List;&#10;&#10;/**&#10; * DTO para respuesta de Google Maps Distance Matrix API.&#10; * https://developers.google.com/maps/documentation/distance-matrix/overview&#10; */&#10;@Getter&#10;@Setter&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class GoogleMapsDistanceResponse {&#10;&#10;    private List&lt;Row&gt; rows;&#10;    private String status;&#10;    &#10;    @JsonProperty(&quot;origin_addresses&quot;)&#10;    private List&lt;String&gt; originAddresses;&#10;    &#10;    @JsonProperty(&quot;destination_addresses&quot;)&#10;    private List&lt;String&gt; destinationAddresses;&#10;&#10;    @Getter&#10;    @Setter&#10;    @NoArgsConstructor&#10;    @AllArgsConstructor&#10;    public static class Row {&#10;        private List&lt;Element&gt; elements;&#10;    }&#10;&#10;    @Getter&#10;    @Setter&#10;    @NoArgsConstructor&#10;    @AllArgsConstructor&#10;    public static class Element {&#10;        private Distance distance;&#10;        private Duration duration;&#10;        private String status;&#10;    }&#10;&#10;    @Getter&#10;    @Setter&#10;    @NoArgsConstructor&#10;    @AllArgsConstructor&#10;    public static class Distance {&#10;        private Long value;  // en metros&#10;        private String text; // &quot;702 km&quot;&#10;    }&#10;&#10;    @Getter&#10;    @Setter&#10;    @NoArgsConstructor&#10;    @AllArgsConstructor&#10;    public static class Duration {&#10;        private Long value;  // en segundos&#10;        private String text; // &quot;7 hours 30 mins&quot;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/servicio-logistica/src/main/java/com/tpi/logistica/servicio/GoogleMapsService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/servicio-logistica/src/main/java/com/tpi/logistica/servicio/GoogleMapsService.java" />
              <option name="updatedContent" value="package com.tpi.logistica.servicio;&#10;&#10;import com.tpi.logistica.dto.googlemaps.GoogleMapsDistanceResponse;&#10;import com.tpi.logistica.dto.googlemaps.DistanciaYDuracion;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.web.client.RestTemplate;&#10;import org.springframework.web.util.UriComponentsBuilder;&#10;&#10;/**&#10; * Servicio para integración con Google Maps Distance Matrix API.&#10; * Calcula distancias y tiempos reales entre ubicaciones.&#10; */&#10;@Service&#10;public class GoogleMapsService {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(GoogleMapsService.class);&#10;    private static final String DISTANCE_MATRIX_URL = &quot;https://maps.googleapis.com/maps/api/distancematrix/json&quot;;&#10;&#10;    @Value(&quot;${google.maps.api.key}&quot;)&#10;    private String apiKey;&#10;&#10;    private final RestTemplate restTemplate;&#10;&#10;    public GoogleMapsService(RestTemplate restTemplate) {&#10;        this.restTemplate = restTemplate;&#10;    }&#10;&#10;    /**&#10;     * Calcula la distancia y duración entre dos direcciones.&#10;     * @param origen Dirección de origen (ej: &quot;Córdoba, Argentina&quot; o coordenadas &quot;-31.4167,-64.1833&quot;)&#10;     * @param destino Dirección de destino&#10;     * @return DistanciaYDuracion con información real de Google Maps&#10;     */&#10;    public DistanciaYDuracion calcularDistanciaYDuracion(String origen, String destino) {&#10;        try {&#10;            String url = UriComponentsBuilder.fromHttpUrl(DISTANCE_MATRIX_URL)&#10;                    .queryParam(&quot;origins&quot;, origen)&#10;                    .queryParam(&quot;destinations&quot;, destino)&#10;                    .queryParam(&quot;key&quot;, apiKey)&#10;                    .queryParam(&quot;language&quot;, &quot;es&quot;)&#10;                    .toUriString();&#10;&#10;            logger.info(&quot;Llamando a Google Maps API: origen={}, destino={}&quot;, origen, destino);&#10;&#10;            GoogleMapsDistanceResponse response = restTemplate.getForObject(url, GoogleMapsDistanceResponse.class);&#10;&#10;            if (response == null || !&quot;OK&quot;.equals(response.getStatus())) {&#10;                logger.error(&quot;Error en respuesta de Google Maps: status={}&quot;, &#10;                    response != null ? response.getStatus() : &quot;null&quot;);&#10;                throw new RuntimeException(&quot;Error al consultar Google Maps API&quot;);&#10;            }&#10;&#10;            if (response.getRows().isEmpty() || response.getRows().get(0).getElements().isEmpty()) {&#10;                throw new RuntimeException(&quot;No se encontraron rutas entre origen y destino&quot;);&#10;            }&#10;&#10;            GoogleMapsDistanceResponse.Element element = response.getRows().get(0).getElements().get(0);&#10;&#10;            if (!&quot;OK&quot;.equals(element.getStatus())) {&#10;                throw new RuntimeException(&quot;No se pudo calcular la ruta: &quot; + element.getStatus());&#10;            }&#10;&#10;            // Convertir metros a kilómetros&#10;            Double distanciaKm = element.getDistance().getValue() / 1000.0;&#10;            &#10;            // Convertir segundos a horas&#10;            Double duracionHoras = element.getDuration().getValue() / 3600.0;&#10;&#10;            logger.info(&quot;Resultado: distancia={}km ({}), duración={}h ({})&quot;, &#10;                distanciaKm, element.getDistance().getText(),&#10;                duracionHoras, element.getDuration().getText());&#10;&#10;            return DistanciaYDuracion.builder()&#10;                    .distanciaKm(distanciaKm)&#10;                    .distanciaTexto(element.getDistance().getText())&#10;                    .duracionHoras(duracionHoras)&#10;                    .duracionTexto(element.getDuration().getText())&#10;                    .origenDireccion(response.getOriginAddresses().get(0))&#10;                    .destinoDireccion(response.getDestinationAddresses().get(0))&#10;                    .build();&#10;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error al llamar a Google Maps API&quot;, e);&#10;            throw new RuntimeException(&quot;Error al calcular distancia: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Calcula distancia usando coordenadas (latitud, longitud).&#10;     * @param origenLat Latitud origen&#10;     * @param origenLng Longitud origen&#10;     * @param destinoLat Latitud destino&#10;     * @param destinoLng Longitud destino&#10;     * @return DistanciaYDuracion&#10;     */&#10;    public DistanciaYDuracion calcularDistanciaPorCoordenadas(&#10;            Double origenLat, Double origenLng,&#10;            Double destinoLat, Double destinoLng) {&#10;        &#10;        String origen = String.format(&quot;%f,%f&quot;, origenLat, origenLng);&#10;        String destino = String.format(&quot;%f,%f&quot;, destinoLat, destinoLng);&#10;        &#10;        return calcularDistanciaYDuracion(origen, destino);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/servicio-logistica/src/main/java/com/tpi/logistica/servicio/SolicitudServicio.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/servicio-logistica/src/main/java/com/tpi/logistica/servicio/SolicitudServicio.java" />
              <option name="originalContent" value="package com.tpi.logistica.servicio;&#10;&#10;import com.tpi.logistica.modelo.Solicitud;&#10;import com.tpi.logistica.modelo.Ruta;&#10;import com.tpi.logistica.modelo.Tramo;&#10;import com.tpi.logistica.repositorio.SolicitudRepositorio;&#10;import com.tpi.logistica.repositorio.RutaRepositorio;&#10;import com.tpi.logistica.repositorio.TramoRepositorio;&#10;import com.tpi.logistica.dto.EstimacionRutaRequest;&#10;import com.tpi.logistica.dto.EstimacionRutaResponse;&#10;import com.tpi.logistica.dto.SeguimientoSolicitudResponse;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import java.util.ArrayList;&#10;&#10;/**&#10; * Servicio que contiene la lógica de negocio para gestionar solicitudes.&#10; */&#10;@Service&#10;public class SolicitudServicio {&#10;&#10;    private final SolicitudRepositorio repositorio;&#10;    private final RutaRepositorio rutaRepositorio;&#10;    private final TramoRepositorio tramoRepositorio;&#10;    private final CalculoTarifaServicio calculoTarifaServicio;&#10;&#10;    public SolicitudServicio(SolicitudRepositorio repositorio,&#10;                            RutaRepositorio rutaRepositorio,&#10;                            TramoRepositorio tramoRepositorio,&#10;                            CalculoTarifaServicio calculoTarifaServicio) {&#10;        this.repositorio = repositorio;&#10;        this.rutaRepositorio = rutaRepositorio;&#10;        this.tramoRepositorio = tramoRepositorio;&#10;        this.calculoTarifaServicio = calculoTarifaServicio;&#10;    }&#10;&#10;    public List&lt;Solicitud&gt; listar() {&#10;        return repositorio.findAll();&#10;    }&#10;&#10;    public Optional&lt;Solicitud&gt; buscarPorId(Long id) {&#10;        return repositorio.findById(id);&#10;    }&#10;&#10;    public Optional&lt;Solicitud&gt; buscarPorNumeroSeguimiento(String numeroSeguimiento) {&#10;        return repositorio.findByNumeroSeguimiento(numeroSeguimiento);&#10;    }&#10;&#10;    public List&lt;Solicitud&gt; listarPorCliente(Long idCliente) {&#10;        return repositorio.findByIdCliente(idCliente);&#10;    }&#10;&#10;    public List&lt;Solicitud&gt; listarPorEstado(String estado) {&#10;        return repositorio.findByEstado(estado);&#10;    }&#10;&#10;    public Solicitud guardar(Solicitud nuevaSolicitud) {&#10;        if (repositorio.existsByNumeroSeguimiento(nuevaSolicitud.getNumeroSeguimiento())) {&#10;            throw new RuntimeException(&quot;Ya existe una solicitud con ese número de seguimiento&quot;);&#10;        }&#10;        return repositorio.save(nuevaSolicitud);&#10;    }&#10;&#10;    public Solicitud actualizar(Long id, Solicitud datosActualizados) {&#10;        return repositorio.findById(id)&#10;                .map(solicitud -&gt; {&#10;                    solicitud.setNumeroSeguimiento(datosActualizados.getNumeroSeguimiento());&#10;                    solicitud.setIdContenedor(datosActualizados.getIdContenedor());&#10;                    solicitud.setIdCliente(datosActualizados.getIdCliente());&#10;                    solicitud.setOrigenDireccion(datosActualizados.getOrigenDireccion());&#10;                    solicitud.setOrigenLatitud(datosActualizados.getOrigenLatitud());&#10;                    solicitud.setOrigenLongitud(datosActualizados.getOrigenLongitud());&#10;                    solicitud.setDestinoDireccion(datosActualizados.getDestinoDireccion());&#10;                    solicitud.setDestinoLatitud(datosActualizados.getDestinoLatitud());&#10;                    solicitud.setDestinoLongitud(datosActualizados.getDestinoLongitud());&#10;                    solicitud.setEstado(datosActualizados.getEstado());&#10;                    solicitud.setCostoEstimado(datosActualizados.getCostoEstimado());&#10;                    solicitud.setTiempoEstimado(datosActualizados.getTiempoEstimado());&#10;                    solicitud.setCostoFinal(datosActualizados.getCostoFinal());&#10;                    solicitud.setTiempoReal(datosActualizados.getTiempoReal());&#10;                    return repositorio.save(solicitud);&#10;                })&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Solicitud no encontrada&quot;));&#10;    }&#10;&#10;    public void eliminar(Long id) {&#10;        repositorio.deleteById(id);&#10;    }&#10;&#10;    /**&#10;     * Estima una ruta para una solicitud.&#10;     * Calcula tramos, costos y tiempos estimados.&#10;     */&#10;    public EstimacionRutaResponse estimarRuta(EstimacionRutaRequest request) {&#10;        // Simula un tramo directo (sin depósitos intermedios por ahora)&#10;        // En una implementación real, aquí se consultaría Google Maps API&#10;&#10;        Double distanciaKm = 150.0; // Simulated - debería venir de Google Maps&#10;        Double consumoPromedio = 0.15; // 15L/100km promedio&#10;&#10;        Double costoEstimado = calculoTarifaServicio.calcularCostoEstimadoTramo(distanciaKm, consumoPromedio);&#10;        Double tiempoEstimado = calculoTarifaServicio.calcularTiempoEstimado(distanciaKm);&#10;&#10;        EstimacionRutaResponse.TramoEstimado tramo = EstimacionRutaResponse.TramoEstimado.builder()&#10;                .origenDescripcion(request.getOrigenDireccion())&#10;                .destinoDescripcion(request.getDestinoDireccion())&#10;                .distanciaKm(distanciaKm)&#10;                .costoEstimado(costoEstimado)&#10;                .tiempoEstimadoHoras(tiempoEstimado)&#10;                .build();&#10;&#10;        return EstimacionRutaResponse.builder()&#10;                .costoEstimado(costoEstimado)&#10;                .tiempoEstimadoHoras(tiempoEstimado)&#10;                .tramos(List.of(tramo))&#10;                .build();&#10;    }&#10;&#10;    /**&#10;     * Asigna una ruta a una solicitud existente y la pasa a estado &quot;PROGRAMADA&quot;.&#10;     * Crea la ruta y sus tramos asociados.&#10;     */&#10;    @Transactional&#10;    public Solicitud asignarRuta(Long idSolicitud, EstimacionRutaRequest datosRuta) {&#10;        Solicitud solicitud = repositorio.findById(idSolicitud)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Solicitud no encontrada&quot;));&#10;&#10;        if (!&quot;BORRADOR&quot;.equals(solicitud.getEstado())) {&#10;            throw new RuntimeException(&quot;Solo se pueden asignar rutas a solicitudes en estado BORRADOR&quot;);&#10;        }&#10;&#10;        // Crear la ruta&#10;        Ruta ruta = Ruta.builder()&#10;                .idSolicitud(idSolicitud)&#10;                .build();&#10;        ruta = rutaRepositorio.save(ruta);&#10;&#10;        // Crear tramo(s) - por ahora solo un tramo directo&#10;        Double distanciaKm = 150.0; // Simulated&#10;        Double consumoPromedio = 0.15;&#10;        Double costoEstimado = calculoTarifaServicio.calcularCostoEstimadoTramo(distanciaKm, consumoPromedio);&#10;        Double tiempoEstimado = calculoTarifaServicio.calcularTiempoEstimado(distanciaKm);&#10;&#10;        Tramo tramo = Tramo.builder()&#10;                .idRuta(ruta.getId())&#10;                .origenDescripcion(solicitud.getOrigenDireccion())&#10;                .destinoDescripcion(solicitud.getDestinoDireccion())&#10;                .distanciaKm(distanciaKm)&#10;                .estado(&quot;ESTIMADO&quot;)&#10;                .fechaInicioEstimada(LocalDateTime.now().plusDays(1))&#10;                .fechaFinEstimada(LocalDateTime.now().plusDays(1).plusHours(tiempoEstimado.longValue()))&#10;                .build();&#10;        tramoRepositorio.save(tramo);&#10;&#10;        // Actualizar solicitud&#10;        solicitud.setEstado(&quot;PROGRAMADA&quot;);&#10;        solicitud.setCostoEstimado(costoEstimado);&#10;        solicitud.setTiempoEstimado(tiempoEstimado);&#10;&#10;        return repositorio.save(solicitud);&#10;    }&#10;&#10;    /**&#10;     * Obtiene el seguimiento detallado de una solicitud con historial cronológico.&#10;     */&#10;    public SeguimientoSolicitudResponse obtenerSeguimiento(String numeroSeguimiento) {&#10;        Solicitud solicitud = repositorio.findByNumeroSeguimiento(numeroSeguimiento)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Solicitud no encontrada&quot;));&#10;&#10;        // Buscar ruta asociada&#10;        List&lt;Ruta&gt; rutas = rutaRepositorio.findByIdSolicitud(solicitud.getId());&#10;        List&lt;SeguimientoSolicitudResponse.EventoSeguimiento&gt; historial = new ArrayList&lt;&gt;();&#10;&#10;        // Agregar evento de creación de solicitud&#10;        historial.add(SeguimientoSolicitudResponse.EventoSeguimiento.builder()&#10;                .fecha(LocalDateTime.now().minusDays(5)) // Simulado&#10;                .evento(&quot;SOLICITUD_CREADA&quot;)&#10;                .descripcion(&quot;Solicitud creada en el sistema&quot;)&#10;                .estado(&quot;BORRADOR&quot;)&#10;                .build());&#10;&#10;        // Si hay ruta, agregar eventos de tramos&#10;        if (!rutas.isEmpty()) {&#10;            Ruta ruta = rutas.get(0);&#10;            List&lt;Tramo&gt; tramos = tramoRepositorio.findByIdRuta(ruta.getId());&#10;&#10;            historial.add(SeguimientoSolicitudResponse.EventoSeguimiento.builder()&#10;                    .fecha(LocalDateTime.now().minusDays(4)) // Simulado&#10;                    .evento(&quot;RUTA_ASIGNADA&quot;)&#10;                    .descripcion(&quot;Ruta calculada con &quot; + tramos.size() + &quot; tramo(s)&quot;)&#10;                    .estado(&quot;PROGRAMADA&quot;)&#10;                    .build());&#10;&#10;            // Agregar eventos de cada tramo&#10;            for (Tramo tramo : tramos) {&#10;                if (tramo.getFechaInicioReal() != null) {&#10;                    historial.add(SeguimientoSolicitudResponse.EventoSeguimiento.builder()&#10;                            .fecha(tramo.getFechaInicioReal())&#10;                            .evento(&quot;TRAMO_INICIADO&quot;)&#10;                            .descripcion(&quot;Inicio de tramo: &quot; + tramo.getOrigenDescripcion() +&#10;                                       &quot; → &quot; + tramo.getDestinoDescripcion())&#10;                            .estado(&quot;EN_TRANSITO&quot;)&#10;                            .build());&#10;                }&#10;&#10;                if (tramo.getFechaFinReal() != null) {&#10;                    historial.add(SeguimientoSolicitudResponse.EventoSeguimiento.builder()&#10;                            .fecha(tramo.getFechaFinReal())&#10;                            .evento(&quot;TRAMO_FINALIZADO&quot;)&#10;                            .descripcion(&quot;Fin de tramo: &quot; + tramo.getOrigenDescripcion() +&#10;                                       &quot; → &quot; + tramo.getDestinoDescripcion())&#10;                            .estado(tramo.getEstado())&#10;                            .build());&#10;                }&#10;            }&#10;        }&#10;&#10;        // Ordenar cronológicamente&#10;        historial.sort((a, b) -&gt; a.getFecha().compareTo(b.getFecha()));&#10;&#10;        return SeguimientoSolicitudResponse.builder()&#10;                .idSolicitud(solicitud.getId())&#10;                .numeroSeguimiento(solicitud.getNumeroSeguimiento())&#10;                .estadoActual(solicitud.getEstado())&#10;                .costoEstimado(solicitud.getCostoEstimado())&#10;                .costoFinal(solicitud.getCostoFinal())&#10;                .tiempoEstimadoHoras(solicitud.getTiempoEstimado())&#10;                .tiempoRealHoras(solicitud.getTiempoReal())&#10;                .historial(historial)&#10;                .build();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.tpi.logistica.servicio;&#10;&#10;import com.tpi.logistica.modelo.Solicitud;&#10;import com.tpi.logistica.modelo.Ruta;&#10;import com.tpi.logistica.modelo.Tramo;&#10;import com.tpi.logistica.repositorio.SolicitudRepositorio;&#10;import com.tpi.logistica.repositorio.RutaRepositorio;&#10;import com.tpi.logistica.repositorio.TramoRepositorio;&#10;import com.tpi.logistica.dto.EstimacionRutaRequest;&#10;import com.tpi.logistica.dto.EstimacionRutaResponse;&#10;import com.tpi.logistica.dto.SeguimientoSolicitudResponse;&#10;import com.tpi.logistica.dto.googlemaps.DistanciaYDuracion;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import java.util.ArrayList;&#10;&#10;/**&#10; * Servicio que contiene la lógica de negocio para gestionar solicitudes.&#10; */&#10;@Service&#10;public class SolicitudServicio {&#10;&#10;    private final SolicitudRepositorio repositorio;&#10;    private final RutaRepositorio rutaRepositorio;&#10;    private final TramoRepositorio tramoRepositorio;&#10;    private final CalculoTarifaServicio calculoTarifaServicio;&#10;    private final GoogleMapsService googleMapsService;&#10;&#10;    public SolicitudServicio(SolicitudRepositorio repositorio,&#10;                            RutaRepositorio rutaRepositorio,&#10;                            TramoRepositorio tramoRepositorio,&#10;                            CalculoTarifaServicio calculoTarifaServicio,&#10;                            GoogleMapsService googleMapsService) {&#10;        this.repositorio = repositorio;&#10;        this.rutaRepositorio = rutaRepositorio;&#10;        this.tramoRepositorio = tramoRepositorio;&#10;        this.calculoTarifaServicio = calculoTarifaServicio;&#10;        this.googleMapsService = googleMapsService;&#10;    }&#10;&#10;    public List&lt;Solicitud&gt; listar() {&#10;        return repositorio.findAll();&#10;    }&#10;&#10;    public Optional&lt;Solicitud&gt; buscarPorId(Long id) {&#10;        return repositorio.findById(id);&#10;    }&#10;&#10;    public Optional&lt;Solicitud&gt; buscarPorNumeroSeguimiento(String numeroSeguimiento) {&#10;        return repositorio.findByNumeroSeguimiento(numeroSeguimiento);&#10;    }&#10;&#10;    public List&lt;Solicitud&gt; listarPorCliente(Long idCliente) {&#10;        return repositorio.findByIdCliente(idCliente);&#10;    }&#10;&#10;    public List&lt;Solicitud&gt; listarPorEstado(String estado) {&#10;        return repositorio.findByEstado(estado);&#10;    }&#10;&#10;    public Solicitud guardar(Solicitud nuevaSolicitud) {&#10;        if (repositorio.existsByNumeroSeguimiento(nuevaSolicitud.getNumeroSeguimiento())) {&#10;            throw new RuntimeException(&quot;Ya existe una solicitud con ese número de seguimiento&quot;);&#10;        }&#10;        return repositorio.save(nuevaSolicitud);&#10;    }&#10;&#10;    public Solicitud actualizar(Long id, Solicitud datosActualizados) {&#10;        return repositorio.findById(id)&#10;                .map(solicitud -&gt; {&#10;                    solicitud.setNumeroSeguimiento(datosActualizados.getNumeroSeguimiento());&#10;                    solicitud.setIdContenedor(datosActualizados.getIdContenedor());&#10;                    solicitud.setIdCliente(datosActualizados.getIdCliente());&#10;                    solicitud.setOrigenDireccion(datosActualizados.getOrigenDireccion());&#10;                    solicitud.setOrigenLatitud(datosActualizados.getOrigenLatitud());&#10;                    solicitud.setOrigenLongitud(datosActualizados.getOrigenLongitud());&#10;                    solicitud.setDestinoDireccion(datosActualizados.getDestinoDireccion());&#10;                    solicitud.setDestinoLatitud(datosActualizados.getDestinoLatitud());&#10;                    solicitud.setDestinoLongitud(datosActualizados.getDestinoLongitud());&#10;                    solicitud.setEstado(datosActualizados.getEstado());&#10;                    solicitud.setCostoEstimado(datosActualizados.getCostoEstimado());&#10;                    solicitud.setTiempoEstimado(datosActualizados.getTiempoEstimado());&#10;                    solicitud.setCostoFinal(datosActualizados.getCostoFinal());&#10;                    solicitud.setTiempoReal(datosActualizados.getTiempoReal());&#10;                    return repositorio.save(solicitud);&#10;                })&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Solicitud no encontrada&quot;));&#10;    }&#10;&#10;    public void eliminar(Long id) {&#10;        repositorio.deleteById(id);&#10;    }&#10;&#10;    /**&#10;     * Estima una ruta para una solicitud.&#10;     * Calcula tramos, costos y tiempos estimados usando Google Maps API.&#10;     */&#10;    public EstimacionRutaResponse estimarRuta(EstimacionRutaRequest request) {&#10;        // Calcular distancia real usando Google Maps API&#10;        DistanciaYDuracion distancia;&#10;        &#10;        if (request.getOrigenLatitud() != null &amp;&amp; request.getOrigenLongitud() != null &amp;&amp;&#10;            request.getDestinoLatitud() != null &amp;&amp; request.getDestinoLongitud() != null) {&#10;            // Usar coordenadas si están disponibles&#10;            distancia = googleMapsService.calcularDistanciaPorCoordenadas(&#10;                request.getOrigenLatitud(), request.getOrigenLongitud(),&#10;                request.getDestinoLatitud(), request.getDestinoLongitud()&#10;            );&#10;        } else {&#10;            // Usar direcciones textuales&#10;            distancia = googleMapsService.calcularDistanciaYDuracion(&#10;                request.getOrigenDireccion(),&#10;                request.getDestinoDireccion()&#10;            );&#10;        }&#10;&#10;        Double distanciaKm = distancia.getDistanciaKm();&#10;        Double tiempoEstimado = distancia.getDuracionHoras();&#10;        Double consumoPromedio = 0.15; // 15L/100km promedio&#10;&#10;        Double costoEstimado = calculoTarifaServicio.calcularCostoEstimadoTramo(distanciaKm, consumoPromedio);&#10;&#10;        EstimacionRutaResponse.TramoEstimado tramo = EstimacionRutaResponse.TramoEstimado.builder()&#10;                .origenDescripcion(distancia.getOrigenDireccion())&#10;                .destinoDescripcion(distancia.getDestinoDireccion())&#10;                .distanciaKm(distanciaKm)&#10;                .costoEstimado(costoEstimado)&#10;                .tiempoEstimadoHoras(tiempoEstimado)&#10;                .build();&#10;&#10;        return EstimacionRutaResponse.builder()&#10;                .costoEstimado(costoEstimado)&#10;                .tiempoEstimadoHoras(tiempoEstimado)&#10;                .tramos(List.of(tramo))&#10;                .build();&#10;    }&#10;&#10;    /**&#10;     * Asigna una ruta a una solicitud existente y la pasa a estado &quot;PROGRAMADA&quot;.&#10;     * Crea la ruta y sus tramos asociados usando datos reales de Google Maps.&#10;     */&#10;    @Transactional&#10;    public Solicitud asignarRuta(Long idSolicitud, EstimacionRutaRequest datosRuta) {&#10;        Solicitud solicitud = repositorio.findById(idSolicitud)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Solicitud no encontrada&quot;));&#10;&#10;        if (!&quot;BORRADOR&quot;.equals(solicitud.getEstado())) {&#10;            throw new RuntimeException(&quot;Solo se pueden asignar rutas a solicitudes en estado BORRADOR&quot;);&#10;        }&#10;&#10;        // Calcular distancia real usando Google Maps&#10;        DistanciaYDuracion distancia;&#10;        &#10;        if (solicitud.getOrigenLatitud() != null &amp;&amp; solicitud.getOrigenLongitud() != null &amp;&amp;&#10;            solicitud.getDestinoLatitud() != null &amp;&amp; solicitud.getDestinoLongitud() != null) {&#10;            distancia = googleMapsService.calcularDistanciaPorCoordenadas(&#10;                solicitud.getOrigenLatitud(), solicitud.getOrigenLongitud(),&#10;                solicitud.getDestinoLatitud(), solicitud.getDestinoLongitud()&#10;            );&#10;        } else {&#10;            distancia = googleMapsService.calcularDistanciaYDuracion(&#10;                solicitud.getOrigenDireccion(),&#10;                solicitud.getDestinoDireccion()&#10;            );&#10;        }&#10;&#10;        // Crear la ruta&#10;        Ruta ruta = Ruta.builder()&#10;                .idSolicitud(idSolicitud)&#10;                .build();&#10;        ruta = rutaRepositorio.save(ruta);&#10;&#10;        // Crear tramo(s) con datos reales de Google Maps&#10;        Double distanciaKm = distancia.getDistanciaKm();&#10;        Double tiempoEstimadoHoras = distancia.getDuracionHoras();&#10;        Double consumoPromedio = 0.15;&#10;        Double costoEstimado = calculoTarifaServicio.calcularCostoEstimadoTramo(distanciaKm, consumoPromedio);&#10;&#10;        Tramo tramo = Tramo.builder()&#10;                .idRuta(ruta.getId())&#10;                .origenDescripcion(distancia.getOrigenDireccion())&#10;                .destinoDescripcion(distancia.getDestinoDireccion())&#10;                .distanciaKm(distanciaKm)&#10;                .estado(&quot;ESTIMADO&quot;)&#10;                .fechaInicioEstimada(LocalDateTime.now().plusDays(1))&#10;                .fechaFinEstimada(LocalDateTime.now().plusDays(1).plusHours(tiempoEstimadoHoras.longValue()))&#10;                .build();&#10;        tramoRepositorio.save(tramo);&#10;&#10;        // Actualizar solicitud con datos reales&#10;        solicitud.setEstado(&quot;PROGRAMADA&quot;);&#10;        solicitud.setCostoEstimado(costoEstimado);&#10;        solicitud.setTiempoEstimado(tiempoEstimadoHoras);&#10;&#10;        return repositorio.save(solicitud);&#10;    }&#10;&#10;    /**&#10;     * Obtiene el seguimiento detallado de una solicitud con historial cronológico.&#10;     */&#10;    public SeguimientoSolicitudResponse obtenerSeguimiento(String numeroSeguimiento) {&#10;        Solicitud solicitud = repositorio.findByNumeroSeguimiento(numeroSeguimiento)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Solicitud no encontrada&quot;));&#10;&#10;        // Buscar ruta asociada&#10;        List&lt;Ruta&gt; rutas = rutaRepositorio.findByIdSolicitud(solicitud.getId());&#10;        List&lt;SeguimientoSolicitudResponse.EventoSeguimiento&gt; historial = new ArrayList&lt;&gt;();&#10;&#10;        // Agregar evento de creación de solicitud&#10;        historial.add(SeguimientoSolicitudResponse.EventoSeguimiento.builder()&#10;                .fecha(LocalDateTime.now().minusDays(5)) // Simulado&#10;                .evento(&quot;SOLICITUD_CREADA&quot;)&#10;                .descripcion(&quot;Solicitud creada en el sistema&quot;)&#10;                .estado(&quot;BORRADOR&quot;)&#10;                .build());&#10;&#10;        // Si hay ruta, agregar eventos de tramos&#10;        if (!rutas.isEmpty()) {&#10;            Ruta ruta = rutas.get(0);&#10;            List&lt;Tramo&gt; tramos = tramoRepositorio.findByIdRuta(ruta.getId());&#10;&#10;            historial.add(SeguimientoSolicitudResponse.EventoSeguimiento.builder()&#10;                    .fecha(LocalDateTime.now().minusDays(4)) // Simulado&#10;                    .evento(&quot;RUTA_ASIGNADA&quot;)&#10;                    .descripcion(&quot;Ruta calculada con &quot; + tramos.size() + &quot; tramo(s)&quot;)&#10;                    .estado(&quot;PROGRAMADA&quot;)&#10;                    .build());&#10;&#10;            // Agregar eventos de cada tramo&#10;            for (Tramo tramo : tramos) {&#10;                if (tramo.getFechaInicioReal() != null) {&#10;                    historial.add(SeguimientoSolicitudResponse.EventoSeguimiento.builder()&#10;                            .fecha(tramo.getFechaInicioReal())&#10;                            .evento(&quot;TRAMO_INICIADO&quot;)&#10;                            .descripcion(&quot;Inicio de tramo: &quot; + tramo.getOrigenDescripcion() +&#10;                                       &quot; → &quot; + tramo.getDestinoDescripcion())&#10;                            .estado(&quot;EN_TRANSITO&quot;)&#10;                            .build());&#10;                }&#10;&#10;                if (tramo.getFechaFinReal() != null) {&#10;                    historial.add(SeguimientoSolicitudResponse.EventoSeguimiento.builder()&#10;                            .fecha(tramo.getFechaFinReal())&#10;                            .evento(&quot;TRAMO_FINALIZADO&quot;)&#10;                            .descripcion(&quot;Fin de tramo: &quot; + tramo.getOrigenDescripcion() +&#10;                                       &quot; → &quot; + tramo.getDestinoDescripcion())&#10;                            .estado(tramo.getEstado())&#10;                            .build());&#10;                }&#10;            }&#10;        }&#10;&#10;        // Ordenar cronológicamente&#10;        historial.sort((a, b) -&gt; a.getFecha().compareTo(b.getFecha()));&#10;&#10;        return SeguimientoSolicitudResponse.builder()&#10;                .idSolicitud(solicitud.getId())&#10;                .numeroSeguimiento(solicitud.getNumeroSeguimiento())&#10;                .estadoActual(solicitud.getEstado())&#10;                .costoEstimado(solicitud.getCostoEstimado())&#10;                .costoFinal(solicitud.getCostoFinal())&#10;                .tiempoEstimadoHoras(solicitud.getTiempoEstimado())&#10;                .tiempoRealHoras(solicitud.getTiempoReal())&#10;                .historial(historial)&#10;                .build();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/servicio-logistica/src/main/resources/application.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/servicio-logistica/src/main/resources/application.properties" />
              <option name="originalContent" value="spring.application.name=servicio-logistica&#10;&#10;# ========== H2 Database Configuration ==========&#10;spring.datasource.url=jdbc:h2:mem:logisticadb&#10;spring.datasource.driverClassName=org.h2.Driver&#10;spring.datasource.username=sa&#10;spring.datasource.password=&#10;&#10;# H2 Console (para desarrollo, ver en http://localhost:8082/h2-console)&#10;spring.h2.console.enabled=true&#10;spring.h2.console.path=/h2-console&#10;&#10;# ========== JPA / Hibernate Configuration ==========&#10;spring.jpa.database-platform=org.hibernate.dialect.H2Dialect&#10;spring.jpa.hibernate.ddl-auto=create-drop&#10;spring.jpa.show-sql=true&#10;spring.jpa.properties.hibernate.format_sql=true&#10;spring.jpa.properties.hibernate.use_sql_comments=true&#10;&#10;# ========== Server Configuration ==========&#10;server.port=8082&#10;server.servlet.context-path=/api-logistica&#10;" />
              <option name="updatedContent" value="spring.application.name=servicio-logistica&#10;&#10;# ========== H2 Database Configuration ==========&#10;spring.datasource.url=jdbc:h2:mem:logisticadb&#10;spring.datasource.driverClassName=org.h2.Driver&#10;spring.datasource.username=sa&#10;spring.datasource.password=&#10;&#10;# H2 Console (para desarrollo, ver en http://localhost:8082/h2-console)&#10;spring.h2.console.enabled=true&#10;spring.h2.console.path=/h2-console&#10;&#10;# ========== JPA / Hibernate Configuration ==========&#10;spring.jpa.database-platform=org.hibernate.dialect.H2Dialect&#10;spring.jpa.hibernate.ddl-auto=create-drop&#10;spring.jpa.show-sql=true&#10;spring.jpa.properties.hibernate.format_sql=true&#10;spring.jpa.properties.hibernate.use_sql_comments=true&#10;&#10;# ========== Server Configuration ==========&#10;server.port=8082&#10;server.servlet.context-path=/api-logistica&#10;&#10;# ========== Google Maps API Configuration ==========&#10;google.maps.api.key=AIzaSyAUp0j1WFgacoQYTKhtPI-CF6Ld7a7jHSg" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>